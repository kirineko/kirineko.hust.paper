---
layout: post
title: "加强安全的指纹识别系统"
description: "硕士论文"
category: other
tags: [other]
---
{% include JB/setup %}

# 加强安全的指纹认证系统

# 摘要
摘要：在用户身份认证领域，尤其是基于网络的用户身份认证领域，指纹认证系统已经得到了越来越广泛的应用。指纹认证已经在电子支付，门禁系统等诸多领域发挥巨大作用。尽管如此，传统的指纹认证系统仍然存在着一些问题，由于传统的指纹识别系统需要采用特定的指纹机来读取指纹，这就导致了系统成本较高，易用性不好。为了解决这些问题，我们采用智能手机终端作为指纹采集设备结合移动互联网Web技术构建了一个新的指纹识别系统原型。在此基础上，我们使用数字水印技术加强系统的安全性。采用新的解决方案，系统可以有效防止信息窃取以及重放攻击。最终我们开发了一个原型系统并进行了相关实验和测试。实验结果表明，采用基于Web的指纹识别系统加强了系统的安全性和可用性，同时大幅度降低了系统的构建成本。

关键词：指纹认证系统; 数字水印; 加密; 网络安全

Abstract: Although use of fingerprint is highly effective in user authentication of networked services such as electronic payment, there are some problems in conventional systems, including high cost due to need for specialized fingerprint readers and limited usability. To resolve these problems, we propose a new system which incorporates a web-based fingerprint authentication using a smartphone as a fingerprint input device. Additionally, a watermark-based encryption solution is used to enhance system security. With this solution, the system can prevent information interception and replay attack. We demonstrate through prototype implementation and experiments that our solution enhances security of web-based system, and the cost and usability problems in conventional systems can also be resolved.

Keywords: fingerprint authentication; watermark; encryption; web security

# 1. 绪论
## 1.1 基于指纹的用户认证系统
指纹认证系统是一种重要的用户认证系统。在未来社会，它的作用会变的越来越重要。一些传统的应用领域如安全系统、门禁系统都需要使用指纹识别技术。随着移动互联网的快速发展，越来越多的新兴应用领域如电子商务、电子支付都可能需要使用指纹识别技术。

传统的指纹识别系统遵循的技术架构如下图所示：

(图1:传统指纹识别系统技术架构)

由上图可讲传统指纹识别系统业务流程归结如下：
1. 使用指纹读取器读取用户指纹信息
2. 指纹读取器连接计算机系统并将用户指纹信息发送给计算机
3. 指纹识别软件将用户的指纹信息与数据库中的用户指纹信息进行对比
4. 指纹识别系统计算指纹相似度，并判断用户是否认证成功，最终将指纹认证结果返回给用户

然而，随着移动互联网的快速发展，这种传统的指纹认证系统的弊端也逐渐显现出来。首先是成本问题，每一个需要使用指纹识别系统的应用场景，都需要购买并部署相应的系统软硬件，这导致了成本的成本的上升。其次是易用性问题，传统的指纹识别系统需要特定的指纹传感器来采集用户的指纹信息，每一个系统部署都需要安装单独的硬件和软件。当系统硬件或软件发生故障时，用户就无法使用指纹系统进行身份认证，易用性较差。

论文研究了传统指纹识别系统的几个主要缺陷，并对其进行了重新识别和改进。我们提出了一个基于Web的指纹认证系统解决方案，使用这种新的解决方案，在传统指纹识别系统中存在的成本和易用性问题将会得到有效解决。

新的系统架构图如下所示：

（图2：新的指纹认证系统解决方案）

该系统具有以下几个方面的创新：
1. 使用智能手机相机取代了传统的指纹传感器，节约系统成本并提高系统可用性。
2. 使用Web Service技术提供跨平台的服务以解决成本问题。

这种解决方案解决了系统成本与易用性问题，但与此同时也产生了系统安全性问题。由于用户的指纹信息通过HTTP协议进行传输，web攻击者可以监听网络请求并从中截获用户的指纹数据，诸如信息截取、重放攻击等网络安全问题也随之产生。由于系统安全事关重大，对我们的系统进行安全保障十分重要。因此，我将首先分析系统的安全性问题。
## 1.2 安全威胁与防御策略
在基于Web的指纹认证系统中将会产生以下几种安全问题：
1）会话劫持。会话劫持的目的往往在于窃取信息内容本身。这种类型的安全攻击通常被认为是数据安全威胁。在指纹认证系统中，客户端需要通过网络向服务器端传输用户指纹数据，在传输过程中，一旦系统遭到攻击，客户端发送的指纹图像数据就有可能遭到窃取，用户的身份数据就会遭到泄漏。

（图3: 会话劫持）

2）重放攻击。重放攻击（Replay Attacks）又称重播攻击、回放攻击或新鲜性攻击（Freshness Attacks），是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。从这个解释上理解，加密可以有效防止会话劫持，但是却防止不了重放攻击。重放攻击任何网络通讯过程中都可能发生。一个经典的重放攻击如下例所示：

（图4: 重放攻击）

在上图中，Bob充当了服务器端的角色，Alice将其个人身份认证信息（用户名、密码）加密后发送给Bob进行认证并认证通过。于此同时，网络中间人劫持了这次会话，中间人截获了Alice向Bob发送的认证数据，尽管该数据是加密的，但中间攻击人并不需要知道数据真实的内容，他只是伪装成Alice再次向Bob发送了同样了认证信息，Bob接收到了同样的认证信息，再次通过了网络中间人的认证请求，并将网络攻击人误认为是Alice.

（图5: 重放攻击例子）

3）数据篡改。这种类型的网络攻击可以认为是重放攻击的扩展。攻击者利用重放攻击破坏系统认证并进入系统，之后攻击者可以很容易地向服务器发送伪造的数据，甚至可以对服务器系统进行SQL注入攻击和系统数据篡改。其基本模式如下图所示：

（图6: 数据篡改）

针对以上几类安全威胁，基本的防御措施如下：

1）图像加密。针对上述第一种攻击类型，通常的解决方法是图像加密。在客户端向服务器发送图像文件之前，首先利用特定的加密算法对图像信息内容进行加密，再将加密后的图像发送给服务器。服务器接收到图像信息之后，利用对应的算法进行图像解密。这种情况下，即使攻击者窃取了图像信息，他仍然无法读取真正的信息内容，有效防止了信息泄漏。

（图7: 图像加密）

2）时间戳认证。针对重放攻击，一种行之有效的办法是采用时间戳认证。采用时间戳认证必须首先保证客户端与服务器端的同步，在此基础上，首先服务器端实时生成随机动态密钥，其次客户端发送请求获取该密钥，最后客户端向服务器端发送用户名和随机密钥以登录系统。在这种情况下，即使中间人截获了登陆信息，密钥的有效期也只有非常短暂的一小段时间。一旦服务器重新生成随机密码，中间人截获的信息就是无效的。

（图8: 时间戳认证）

3）请求应答认证。请求应答认证是另一种防止重放攻击的有效方法。其基本模型如下所示：
	1）客户端发起登陆请求。（可假设登陆请求是一个Get请求）
	2) 服务器端生成一个随机数K＝random（num），并将K返回给客户端。于此同时，服务器端缓存中保存该K值。
	3）客户端计算R＝ Hmac（K，P），在该公式中，K代表密钥，是服务器返回的随机数，P代表用户密码，Hmac是一个用于加密的哈希函数。
	4）服务器端从数据库读取用户密码，并进行与步骤3中相同的哈希函数运算R‘＝hmac（K，P’），然后比较R和R‘，如果二者相等，用户登陆系统成功。
在这种模型下，中间人只能获取传输中的K值和R值，由于K值是一个随机数，R值是一个哈希函数结果，因此这两个值都是无意义的。中间人无法通过这两个值获取用户密码，也无法发起重放攻击。因此提升了系统的安全性。

（图9: 请求应答认证）

## 1.3 基于数字水印的指纹认证系统

通过以上两部分分析，论文将主要探讨加强安全的指纹认证系统。首先，我们提出了一个新的解决方案取代传统的指纹认证系统。在新的解决方案中，我们没有采用传统的指纹读取器等硬件设备获取用户指纹信息，我们采用了智能手机中的相机模块获取相应的用户信息。这样就导致了系统更加便利，同时也降低了系统成本。其次，我们采用Web Service技术提供加强安全的Web网络认证服务。我们加入了一些安全策略以提高系统安全性并防止重放攻击。最终我们开发了一个系统原型，该系统原型解决了现有解决方案的高成本、低效率问题，具有低成本、便利、安全等优势。

## 1.4 论文章节结构安排

论文的章节结构安排如下：

论文第一章为绪论部分，讨论了现有指纹认证系统的问题，结合移动互联网、Web安全等技术提出了一个新的基于Web Service的加强安全的指纹认证解决方案。

论文第二章为相关技术介绍，介绍了新解决方案所使用的几个关键技术，包括指纹识别技术，数字水印技术，Zxing开源框架、SOA技术与Web Service以及Nancy Framework。

论文第三章为模型与需求，针对新的解决方案，建立了一些系统模型，并分析讨论了各个模型的问题，最终建立了一个比较安全可靠的系统模型，最后给出了需求建模。

论文第四章为系统架构设计部分，首先介绍了与系统密切相关的业务逻辑，然后给出了基于REST的系统架构设计方案，最终进行了数据库设计与建模。

论文第五章为系统实现部分，分模块实现了系统分析与设计中的功能，并详细探讨了系统中用到的关键算法。

论文第六章为系统实验结果部分，从成本、可用性、安全性等角度分析系统试验结果。

论文第七章为总结与展望部分，对基于Web的加强安全的指纹识别系统进行了总结，对系统开发中的核心问题和难点进行提炼，并对指纹认证系统的未来进行了展望。

# 2. 关键技术简介
本章介绍与指纹认证系统相关的一些技术，由于基于Web的指纹认证是一个复杂的综合性系统，因此涉及到很多方面，这里只是对相关的重点技术进行简要介绍。
## 2.1 指纹识别技术
指纹识别技术是任何指纹识别系统的核心和关键技术。就指纹识别本身而言，大致可以分为以下5个步骤：第一步，指纹数据采集。利用相应的图像采集设备获取指纹图像信息。第二步，指纹预处理。由于采集到的指纹图像是未经加工的，初步的。因此，需要进行指纹图像的预处理，包括图像的增强处理，边缘检测，直方图均衡化等，经过处理的指纹图像应能达到下一步特征提取和匹配的要求。第三步，特征提取。根据指纹的特点，对指纹图像进行特征提取，获取指纹的特征点信息。第四步，指纹匹配。将两个指纹之间的特征点信息进行对比和匹配。第五步，处理匹配结果。根据指纹对比匹配的结果，判断两个指纹之间的相似度，决定指纹是否匹配成功。在指纹识别领域，采用FAR（认假率）和FRR（拒真率）来衡量指纹识别算法的好坏。一般而言，一个好的指纹识别系统应该保证FAR和FRR尽可能的低。

目前指纹识别技术发展比较成熟。出现了一些著名的开源软件和一大批商业软件，比较有名的有美国国家标准与技术研究院NBIS课题组开源的NBIS指纹识别系统，基于NBIS的SourceAFIS系统，以及CrossMatch公司的U.Are.U SDK.许多指纹识别系统采用的指纹识别技术均基于此。这里简要介绍一下NBIS指纹识别软件。NBIS指纹识别软件是由美国国家标准与技术研究院NBIS课题组开源的指纹识别系统。该系统可在类Unix环境下运行，提供了Mindtct特征提取工具，IMGTOOLS指纹图像处理工具，BOZORTH3指纹匹配工具，在Unix命令环境下可以方便地对指纹专有图像进行特征提取与处理。由于NBIS系统比较复杂，对系统环境配置要求较高，因此出现了基于NBIS的SourceAFIS开源库。SourceAFIS对NBIS进行了简化，抽取了Mindtct与BOZORTH3的核心功能，并与.net和Java技术相结合，提供了.net版本和Java版本更便于实际使用。

Chris Stein, Claudia Nickel 和 Christoph Busch 使用上述相关技术给出了一个基于智能手机相机的指纹识别系统解决方案，并使用android手机开发了原型系统。但是由于该系统并不是基于Web Service的，因此只实现了基本功能，许多安全性问题没有考虑。

## 2.2 数字水印技术
数字水印技术是保证信息来源真实可靠的重要的技术。客户端对原始信息加水印可以保证信息来源的准确可靠，服务器接收到客户端发送的水印信息之后，可以先分析水印信息，确保客户端的身份，之后在对水印信息进行去水印，对原始信息进行处理。如果客户端在加水印过程中融合了时间戳技术和挑战应答技术，就可以保证系统的安全性，加水印的数据既可以防止信息内容泄漏，又可以识别信息来源的真实性，防止重放攻击。因此，数字水印技术是加强系统安全的不二选择。

客户端加水印，服务器端去水印。这种数字水印技术被称为可逆数字水印技术，是水印技术发展的难点之一。实现数字水印的方法有很多，最基本的方法当属最低有效位算法。Waiton最早提出了最低有效位算法来实现数字水印，Waiton使用图像中的低位信息存储密钥信息，用图像中的其他位信息生成密钥信息，这样低位存储的密钥信息就成为数字水印。用该种算法生成的可逆水印简单容易使用。A.Z.Tirkel, R.G.van Schyndel, C.F.Osborne基于最低有效位算法提出了二维数字水印技术，并讨论了该技术在JPEG图像转换的适用性。Zhang Ning, Zang Ya-Li, Tian Jie结合生物识别技术和密码技术提出了一个新的身份认证解决方案，并讨论了指纹识别技术和安全密钥技术的结合。
## 2.3 ZXing开源框架
ZXing Project全称zebra crossing，是由Google公司开源的条形码与二维码图像处理库，能简单快速地生成和解析多种条形码和二维码，支持UPC，EAN，Codebar，QR Code，Data Matrix多种条形码标准，该开源库采用Java实现，并提供了多种其他语言接口。ZXing框架包含以下几大模块：code模块，条形码编码解码核心模块；javase模块，javse客户端模块；android模块，android客户端模块，android-test模块，android客户端测试模块；android-integration模块，支持Intent集成条形码预览；glass模块，简单的google眼睛应用实例等。使用Zxing框架，可以在系统中简单方便地集成条形码处理功能，大大简化了系统处理条形码和二维码的难度。Eui-Hyun Jung 和 Seong-Yun Cho研究了条形码技术和数字水印技术，然后提出了采用二维条形码的数字水印解决方案。

## 2.4 SOA与Web Service
SOA与Web Service技术是服务器端实现的重点与核心技术。这里将进行重点探讨。
### 2.4.1 SOA
SOA即是面向服务的架构（service-oriented architecture）.简单的说，SOA是开发应用系统的一种新架构，在基于SOA的系统中，应用程序的构建过程类似于服务组件的组合过程。这些组件都是松耦合的并具有明确的接口定义，我们通常将这些组件称为服务。SOA技术架构的优点是实现系统的跨平台性和优良的可扩展性。

举例而言，在我们的指纹认证系统中，我们需要实现一个android客户端和一个服务器端，android客户端与服务器端通信，调用服务器端提供的API接口服务以实现录入指纹和指纹认证的功能。在传统的软件体系结构下，客户端与服务器端的开发必须置于同一技术架构之下，如果客户端采用Android技术实现，相应的，服务端也必须采用Java EE技术实现；如果要开发Windows Phone的客户端，也必须开发对应的.net框架下的服务器程序。这种传统的软件架构模型是一种紧凑的架构体系，其优势在于服务器与客户端紧密协作，共同依赖相同类型的核心组件。然而，这种架构体系的缺点也是很明显的，最突出的问题的扩展性较差。如果采用.net技术进行客户端的开发，那么也意味着服务器端也必须采用同样的技术，这种传统的软件架构模型不适应移动互联网时代的业务发展需求。

在移动互联网时代，一个服务往往需要支持多种客户端共同调用。举例来说，社交软件"Line"就需要为多种客户端提供多种服务，比如登录服务既需要支持PC客户端进行登录，同时也要提供对Android手机客户端和iOS手机客户端的登录支持，甚至还要提供对Web浏览器的登录支持。如果我们采用传统的系统架构，我们需要为每一种平台编写服务端代码，然而许多服务代码都是类似甚至是重复的，这样就不符合软件工程中的基本原则——DRY原则（Don't Repeat Yourself）.在这种移动互联网的背景下，SOA架构迅猛发展。

在SOA架构体系下，每一个应用功能被封装成服务，这些服务都是与具体平台无关的。客户端与服务器端的通信通过消息传递进行。通信的数据应符合数据传输的标准和规范，如XML和JSON.当客户端需要调用服务API时，客户端向对应的服务接口发一条消息，服务器端解析消息并响应客户端消息请求，向客户端返回标准化数据，客户端解析标准化数据获取最终结果。这样就实现了从面向具体技术的架构向面向服务的架构的迁移。无论客户端采用android技术还是iOS技术，抑或是Web技术，甚至是桌面应用程序，他们都可以调用同一个服务接口，并且不需要修改服务器端代码。SOA架构显著增强了系统的跨平台性和可扩展性，现在SOA架构已然成为了移动互联网领域的主流架构模型，而Web Service是实现SOA体系的一种具体技术。
### 2.4.2 Web Service
Web Service技术是一种实现SOA最为通用和主流的技术。它通过Web标准与协议提供Web服务。Web Service的目的在于实现异构系统间的相互协作。

经过数年的发展，目前Web Service技术已经发展为以下两大主要类型：
1）基于SOAP的Web Service
2）基于REST的Web Service

基于SOAP的Web Service: SOAP是简单对象访问协议的缩写，被用来描述信息传输的格式，WSDL是网络服务描述语言的缩写，用于描述Web服务的公共接口，UDDI是统一描述、发现和集成的缩写，用于管理、发布和查询Web Service. SOAP使用两大应用广泛的协议————HTTP和XML. HTTP被用来实现RPC风格的SOAP传输，XML是其编码形式。通过SOAP，Web Service具有了优秀的扩展性，与特定技术、编程语言、平台的完全独立性。

基于REST的Web Service: RT Fielding博士在其博士论文"Architectural Styles and the Design of Network-based Software Architectures"中首次提出了REST风格的Web Service的基本概念。REST是表述性状态转移的缩写，REST风格具有以下几个特点：
1）首先，REST是一种架构风格，不是一个具体的标准；
2）REST风格是基于资源的架构风格；
3）REST架构风格的目的是实现一个组织良好的Web应用程序；
4）REST架构风格是对HTTP协议的真正充分利用：
	－ 它逻辑上通过URI来定位资源；
	－ 它通过HTTP请求头信息来判断客户端需要获取何种资源或是对资源进行何种操作
	－ 在REST风格体系中，使用不同HTTP的请求方法来实现CRUD操作（增删改查操作），具体而言，GET操作可以获取资源，POST操作可以添加资源，PUT操作可以更新资源，DELETE操作可以删除资源，等等。

REST架构风格的以上特点使它比基于SOAP的Web Service更简单，更轻量，更能够完全地利用HTTP协议，REST风格实际上代表了HTTP设计之初的真正意图，因此，近年来REST风格的Web Service已经完全改变了Web Service的状况，极大地适应了移动互联网的发展趋势，现在，主流的移动客户端开发都已经从SOAP向REST架构风格进行迁移。在我们的指纹认证系统中，为了配合android客户端的开发，服务器端同样也将采用REST风格的Web Service实现。

## 2.5 Nancy Framework
我们使用Nancy Framework来实现轻量级的REST风格Web Service. Nancy Framework是一个基于.net和mono平台的轻量级的Web框架，它遵循MVC模式并被设计用来支持REST风格的Web Service. Nancy官方网站对Nancy框架的特征介绍如下：
	-Nancy 是一个轻量级用于构建基于HTTP的Web服务，基于 .NET 和 Mono 平台，框架的目标是保持尽可能多的方式，并提供一个super-duper-happy-path所有交互。
	-Nancy 设计用于处理DELETE, GET, HEAD, OPTIONS, POST, PUT和PATCH  等请求方法，并提供简单优雅的DSL以返回响应。
	-Nancy和Asp.net MVC原理相似，但有自己的一套路由机制，在使用上更加易用，可以用Nancy快速开发一些网站。
	-Nancy并不依赖任何现有的框架，所以他可以运行在任何平台上面。
	(http://www.cnblogs.com/yunfeifei/p/4109318.html?utm_source=tuicool&utm_medium=referral)

下面介绍Nancy框架的核心思想。
### 2.5.1 MVC
Nancy框架的设计灵感来源于Ruby中的Sinatra框架，他们的基本思想都是MVC模式，MVC模式是模型－视图－控制器模式的缩写。
- 模型是应用系统用于描述数据逻辑的部分，通常用于封装数据对象以存储数据
- 视图是应用系统中描述显示逻辑的部分，视图负责展示给用户的界面逻辑，视图中的数据通常通过模型层获取。
- 控制器是应用系统中业务逻辑处理的部分，负责从视图中读取数据，处理用户输入跳转，将数据发送给模型等业务逻辑处理，是系统的控制中枢，也是MVC模式的核心部分。

上图展示了MVC模式的核心工作流：
1）首先，用户向应用程序程序发送请求，等待服务端响应
2）控制器接收用户请求，然后由控制器决定是从模型中读取数据还是直接将用户请求交给对应的视图进行响应。
3）控制器向模型层发送数据请求。
4）模型层从数据库中读取请求的数据，并将获取到数据返回给控制器。
5）控制器将模型返回的数据发送给响应的处理视图。
6）视图层通过从模型中获取数据填充视图内容，并将最终的HTML结果返回给控制器。
7）控制器将结果视图返回给用户。

通过MVC模式，实现了应用系统业务逻辑和表现逻辑的分离，数据逻辑和数据库系统的分离，因此降低了模块之间的耦合性，也便于前后端开发人员的相互协作。因此越来越多的应用系统采用MVC模式实现，于此同时也产生了大量优秀的遵循MVC模式的框架，如Ruby on Rails， Java Spring MVC，ASP.net MVC等等。我们所采用的Nancy框架也是.net平台上的一个轻量级的MVC框架。
### 2.5.2 Nancy框架中的MVC实现
Nancy框架是.net平台下基于MVC模式的轻量级Web框架，一个Nancy项目结构如下图所示：

在Nancy框架中，Model表示模型模块，Views表示视图模块，Mudule表示控制器模块。
1. 控制器遵循REST风格，其基本的工作模式是：当用户在浏览器中请求uri http://hostaddress/ 时，Nancy框架中的控制器类会首先通过uri查找对应的控制器，这种机制被称为路由机制，这种路由机制也是Nancy框架实现Rest风格的Web Service的核心。当用户向服务器根目录uri发送GET请求时，控制器会首先通过路由机制查找GET["/"]控制器，在找到响应的控制器之后，用户请求会被对应的控制器进行处理。而对应的控制器可能会调用对应的视图资源或模型资源来响应用户请求。

2. 视图遵循HTML作为其基本风格，在Nancy框架中，官方支持的视图引擎是Radar视图引擎，Radar引擎的语法与HTML基本类似。

3. 视图层将数据库组织成相应的对象，并支持大多数的ORM框架。

在论文中，我们将结合以上多种核心技术来构建我们的指纹认证系统原型。

# 3. 模型与需求
本章探讨的主要问题是模型与需求，将主要讨论指纹认证系统的安全策略问题，通过讨论相应的安全策略确立一种优良的系统解决方案模型，在此基础上提出需求建模。在本章中，首先我们会简要地分析系统安全威胁；其次我们会讨论加强系统安全的传统解决方案；然后我们提出了基于可逆数字水印的新的安全解决方案，并对其进行了逐步改进。最后我们确立了解决方案模型和系统需求模型。
## 3.1 原有的解决方案
### 3.1.1 安全威胁
正如我们在论文第一章讨论的那样，Web系统中存在多种类型的安全攻击。其中一种攻击是会话劫持，会话劫持的目的在于窃取信息内容本身。另一种攻击是重放攻击，重放攻击的目的主要在于破坏认证的有效性。在我们的指纹认证系统中，网络攻击者会尝试劫持包含有用户指纹信息的用户数据包，这是一种典型的会话劫持类攻击，攻击者的目的在于盗取用户的指纹信息，在这种情况下，用户信息将会被窃取。此外，攻击者在截获了用户发送的指纹数据包之后，会假冒用户向服务器再次发送该指纹数据包，以骗取服务器信任，即使用户发送的指纹数据包经过加密也无法防止这种攻击，这种攻击是一种典型的重放攻击。攻击者通过重放攻击以达到欺骗认证服务器的目的，这种情况下服务器会把攻击者认定为原始的用户，通过指纹认证。

可见在我们的指纹认证系统中同时包含了以上两类安全隐患，指纹认证系统应该是足够安全的。因此，我们尝试设计安全子系统以加强系统的安全性，最终使我们的系统可以同时防御会话劫持和重放攻击两种类型的攻击。

### 3.1.2 通常的解决方案
文件加密和数字签名是加强系统安全性的最通用的解决方案。其中文件加密主要用于防止信息内容泄漏，而数字签名主要用来确保信息来源的真实可靠性。

文件加密: 文件加密的基本流程是通过特定的算法对原始文件信息进行编码，使经过加密的文件变的不可读，我们可以将其称之为密文。在没有密钥的情况下原始文件信息是无法获取的。通过这种方式我们可以有效的防止数据被非法窃取。对应的，文件加密的逆过程也被称为文件解密。
数字签名: 数字签名技术本质上是通过数学方法来验证消息、软件和数字文件来源的真实性和可靠性。数字签名的基本流程如下图所示：

从上图中我们可以了解到数字签名技术的工作原理。首先，数据发送方使用他的私钥对他需要发送的信息进行加密，这样他就获得了签名消息；其次，数据发送方讲签名消息发送给接收方。数据接收方接收签名消息，并利用公钥对签名消息进行解密，解密后，接收方将获得解密后的Hash值，如果接收方解密后的Hash值与发送方的Hash值相匹配，则证明消息在签名之后没有被篡改，否则则证明数据在签名之后遭到攻击者攻击，信息内容已经被改变。

### 3.1.3 传统解决方案的问题
上述传统解决方案对于加强系统安全性和抵御网络攻击能够起到良好的效果。但是应用在我们的指纹识别系统中仍然有一些缺陷和问题。
首先是系统复杂性的问题，数字签名需要另外一整套复杂的架构，此外，我们可能需要将安全系统拆分成2个子系统，一个子系统用来进行文件加密，另一个系统进行数字签名。这就导致了系统架构的进一步复杂化。其次，上述两种解决方案是一种通用的解决方案，并没有考虑到指纹识别系统的特殊性，也没有结合指纹图像的特征。鉴于此，我们提出了一个新的安全解决方案。
## 3.2 新的解决方案
为了克服传统解决方案的上述缺陷，在本部分我们将提出一个新的解决方案。首先，我们会分析在没有加入安全措施的情况下系统可能产生的问题，之后我们会在这些问题的基础上，对解决方案进行逐步改进和优化。
### 3.2.1 安全漏洞
首先，在不采用文件加密和数字签名的情况下，我们会发现原始的指纹认证系统会产生如下安全漏洞。

（图片：已知的问题）

在上图所示的业务场景下，用户A希望采用本系统进行身份认证，该名用户采用智能手机采集他的指纹图像，之后用户A直接向服务器发送该图片以进行匹配。然而此时网络攻击者B正在监听此次通信过程，网络攻击者B是一个恶意监听者并且盗取了用户A的指纹图像信息。几分钟之后，攻击者B假扮A向服务器发送刚刚窃取到的指纹图像。这样系统会把攻击者B当作是真正的用户A，B就成功获取了系统认证。在这种情况下，由于B获得了与A相同的系统认证，对于用户A而言显然是不安全的。可见，原始的指纹认证系统无法防止会话劫持和重放攻击，我们需要在系统中加入一些安全策略以增强系统的安全性。

### 3.2.2 第一次改进
为了增强系统安全性，我们在系统中引入了安全模块。

引入安全模块的两个关键点在于：
（1）为了防止指纹图片信息泄密，客户端不应该将最原始的指纹图像信息发送给服务器。
（2）为了防止重放攻击，系统可以采用一种类似于一次性密码本的加密技术。这意味着系统需要生成一个单次有效的密钥。为了实现上述系统，我们可以基于时间戳来产生密钥。当用户需要进行指纹认证时，服务器端首先检查时间戳密钥，如果时间戳密钥正确，再进行指纹认证操作，否则系统不能确定请求来源的可靠性，就不再进行指纹认证操作。

为了实现以上两个关键点，我们结合了二维码技术来构建指纹认证系统。首先，服务器端根据时间戳来生成对应的二维码图片然后将该图片发送给客户端。在这种情况下，由于二维码图片包含有时间戳信息，因此可以作为一次性密钥来防止重放攻击。此外，我们可以将二维码图片和原始的指纹图片相结合，这样客户端发送图片时可以采用新的图片代替原始的指纹图片。最终，加入了二维码技术的安全模块满足了上述两点安全需求。

（图片：第一次改进）

改进后的系统解决方案如上图所示。在这种情况下，用户A首先拍摄指纹图片，其次他向服务器发送请求，服务器接收到用户认证请求后首先根据当时的时间戳生成相应的二维码图片并将该图片返回给客户端。客户端接收到二维码图片之后，将拍摄到的原始的指纹图片放置于二维码图片中心位置产生了一个新的图片。接着，客户端将新的图片发送给服务器，服务器端接收到新的图片以后，首先对二维码进行解码获得时间戳信息，判断时间戳信息是否正确。如果与服务器端生成时保存的时间戳一致，系统就将指纹图片提取出来发送给匹配模块，否则服务器会直接返回认证失败信息给客户端。

现在我们再来分析新系统的安全性。此时，攻击者B仍然能够通过会话劫持窃取包含二维码和指纹的新图片。但是，由于图片是二维码和指纹图片的混合，攻击者不能再直接获取原始的指纹图片了。更重要的是，攻击者不再能够进行重放攻击。如果攻击者B再次向服务器发送他刚刚劫持到的图片，图片中的时间戳已经不再有效，原因在于时间戳认证在B重发消息之前已经被认证过了，而时间戳仅一次有效。因此，服务器不会将攻击者B发送的图片分发给匹配模块作进一步处理。服务器会直接返回失败消息给攻击者。

由此可见，指纹认证系统的安全性已经得到了显著的改进与增强。然而该系统仍然是不安全的。攻击者仍有许多办法来获取原始的指纹图片，攻击者只需要将截获到的新图片进行中心部分裁剪就可以轻松地还原出原始的指纹图片，再他们获取到了原始的指纹图片以后，攻击者可以重新向服务器发送认证请求以获取新的二维码图片。这样，他们只需要将二维码图片与原始图片进行结合就可以再次将图片发送给服务器进行认证。这又变成了一种重放攻击，在这种场景下，由于时间戳消息是全新可用的，攻击者可以通过服务器端的时间戳检查。这样攻击者就成功通过了系统认证。为了防止这种情况的发生，该解决方案仍然需要进一步改进。

### 3.2.3 第二次改进

这次改进的核心思想和第一次改进基本相同。上述解决方案的主要问题在于，客户端只是简单直接地将指纹图片与二维码图片进行了拼接，由于指纹图片本身并没有被隐藏起来，这使得新产生的图片很容易被破解。因此，如果我们能够采用一种算法使指纹图片隐藏起来，攻击者就很难对截获到的图片进行还原。这样系统安全性就会大大提高。

此时，我们将可逆数字水印技术加入我们的指纹认证系统中。采用这一技术，我们可以轻松地将原始指纹图片和二维码图片进行组合，于此同时可以将指纹图片隐藏起来。这样，就可以把指纹图片作为数字水印隐藏起来，而不是将其直接发送给服务器。

上图展示了本次改进后新解决方案的基本流程。该解决方案与第一次改进后的方案基本类似。我们只是采用了数字水印代替了之前的直接组合。客户端把指纹图片作为数字水印并将其编码进二维码图片当中。服务器端接收包含数字水印的二维码图片，然后调用解码模块对二维码图片进行解码。解码之后，服务器端会将原始二维码图片和原始的指纹图片进行分离，接着服务器就可以检查二维码中的时间戳信息，如果时间戳正确，则对指纹图片进行匹配操作，否则返回认证失败。

经过这样的加密，系统安全性显著提高。攻击者再也不能很轻易地获取原始的指纹图片了。攻击者只能截获到一张二维码图片，而这张图片本身对身份认证是没有任何意义的。如果攻击者尝试还原原始的指纹图片信息，他们必须知道相应的数字水印加密算法，否则他们就无法破解出真实的指纹信息。然而，一旦系统加密算法被泄漏，攻击者仍然可以破解出原始的指纹信息，这样一来，系统仍然是不够安全的。因此，我们还需要对指纹系统进行进一步的改进。

### 3.2.4 第三次改进
第三次改进则非常简单。我们在最终的系统中加入密钥机制。在第二次系统改进的基础上，我们采用用户密码作为密钥对上次改进中的图片进行再加密，客户端将再加密之后的图片发送给服务器。服务器端接收到图片以后首先根据用户名在数据库中查找相应的用户密钥，然后根据用户密钥对图片进行解密，在解密之后，服务器端执行与上一部分相同的操作即可。第三次改进如下图所示：

（图片）

这样，攻击者必须通过掌握了系统加密算法和用户密钥之后才能还原出原始的指纹图像，大大增加了破解的难度和成本。因此，我们认为经过三次改进后的系统已经足够安全。

## 3.3 需求建模
下面，我们基于上述解决方案分析对系统进行需求建模。本部分采用面向对象的需求分析方法对上述解决方案进行需求分析，首先给出了系统整体用例图，然后对用例图进行了具体描述。
### 3.3.1 总体用例图
系统总体用例图如下所示：

（总体用例图）

### 3.3.2 用例描述
从总体用例图可以看出，系统参与者主要用两类：游客Guest和用户User,而由于本系统和拥护身份认证等敏感操作息息相关，因此本系统游客除了注册登录以外并没有任何可用操作。对于游客而言，他们只有用户注册和用户登录两个用例。游客进行登录操作以后，游客就转化为用户User. User是本系统的核心参与者，拥有指纹录入和指纹认证两个用例。这两个用例又分别包含一些子用例。现进行详细描述。

指纹录入用例，是用户通过指纹机将自己的所有指纹录入进指纹认证系统后台数据库中，指纹录入是指纹认证的基础。该用例包含2个子用例：上传身份信息用例和上传指纹图片用例。在上传指纹图片之前，必须对指纹本身的用户信息先录入后台数据库，即上传身份信息，在上传身份信息之后，才可以开始正式的指纹图片录入。

指纹认证用例，是用户通过手机拍照验证自身指纹是否匹配的过程。该用例包含4个子用例：二维码生成用例、数字水印生成用例、来源审核用例、指纹对比用例。其中二维码生成、数字水印、来源审核都属于系统的安全模块，用于增强系统的安全性，防止会话劫持和重放攻击。二维码生成用例会根据请求的时间戳生成相应的二维码图像；数字水印用例会将二维码图像和原始指纹图片进行可逆水印计算生成数字水印；来源审核用例主要用来检查数字水印中包含的时间戳信息以判断请求来源的合法性；指纹对比用例主要用来比较用户指纹图片的匹配度，是指纹匹配的核心用例。

# 4. 系统架构设计
本章探讨的主要问题是系统的架构设计。在确定了系统的解决方案和需求建模之后，必须根据相关的用例模型并结合特定的技术进行系统设计，系统设计与特点的技术选型息息相关。本章共分为3部分，第一部分依据系统用例分析结合特定的API函数分析系统业务逻辑，第二部分基于REST Web Service给出了系统架构设计整体方案和详细设计方案，第三部分在面向对象设计的基础上进行数据库设计。

## 4.1 系统业务逻辑
本部分讨论系统业务逻辑，首先对系统组件进行详细划分，然后对整个系统的基本业务逻辑进行阐述。
### 4.1.1 系统组件

系统组件包含以下四部分：
（1）客户端：包含Android智能手机、指纹数据采集子模块、指纹特征提取子模块、指纹加密子模块。
（2）服务器端：包含Web服务器、指纹解密子模块、用户认证子模块、指纹匹配子模块。
（3）第三方组件：包含指纹匹配SDK，SourceAFIS SDK、NBIS SDK、Zxing.net、Nancy Framework等组件。
（4）数据库：包含指纹图像数据库、用户数据库等。

### 4.1.2 工作流分析

系统基本业务流程如下图所示：

（业务流程图）

（1）指纹图像采集：用户登录android客户端，android客户端调用手机相机和图像采集模块获取用户指纹图像。
（2）指纹图像处理与特征提取：客户端调用图像处理模块对指纹图片进行预处理，在此基础上对用户指纹进行特征提取。
（3）图像加密：首先客户端接收来自服务器端生成的二维码图片，然后客户端调用加密模块对原始指纹图片和二维码图片进行数字水印加密。
（4）图片上传：客户端调用Web API将加密后的指纹图片上传至服务器。
（5）图像解密：服务器端调用解密模块对加密的指纹图片进行解密，解密后服务器同时获得二维码图片和原始指纹图片。
（6）用户认证：服务器端调用用户认证子模块来检查二维码图片中的时间戳信息是否一致以确保用户来源的真实性。
（7）指纹匹配：服务器端调用指纹匹配SDK对用户上传的指纹图片和数据库中保存的指纹信息进行匹配和对比，得到相应的指纹匹配结果。
（8）结果显示：服务器将匹配结果返回给客户端，客户端根据匹配分数判断用户是否通过指纹匹配认证。指纹认证过程完成。

## 4.2 基于REST的系统架构设计
本部分是系统设计部分，首先进行系统整体架构设计，然后介绍了系统类设计方案，最后分模块进行了模块详细设计。
### 4.2.1 整体架构设计
在介绍系统架构设计之前，首先介绍系统的技术选型。在不考虑第三方类库的平台支持情况下，由于指纹认证系统规模并不大，因此可以采用一些快速开发框架如Ruby on Rails或Node.js进行开发，并将服务器部署在Linux的Nginx服务器上，但是由于系统中采用了SourceAFIS指纹识别开源库，并且该开源库仅提供了完善的.net版本。因此本系统在技术选型过程中，底层指纹匹配服务只能基于.net构建。最终采用了windows 10作为操作系统平台，IIS8作为Web服务器，MySql 5.6作为数据库服务器，.net Nancy Framework作为服务端开发框架。使用Nancy Framework提供Web API，顶层实现了Android端、iOS端等客户端。

系统整体架构图如下图所示：

从整体架构图中可以看出，系统共分为5层。底层为数据库层，采用MySQL提供DBMS服务，其次为模型层，在Nancy Framework中建立相应的模型类，中间为控制器层，使用Nancy Framework中的控制器组件编写具体的系统业务逻辑，上层为API层，通过路由机制提供对应的Web API服务，向应用层提供所需的JSON数据，最顶层为应用层，包括但不限于Android端、iOS端、Web端等具体的应用服务，这些应用服务通过解析Web API中提供的JSON数据填充其视图。

### 4.2.2 系统类设计

在整体架构设计的基础上，在Nancy框架的基础上进行类设计。类设计的基本思路是：
（1）数据层与控制层分离，控制层与表现层分离，反映边界类和实体类的区别，反映实体类之间之间的继承与组合关系。
（2）通过设计接口实现面向接口的设计而非面向实现的设计。
（3）设计控制器类操作数据实体类
（4）实体类与实体类之间通过关联类建立联系。

系统类图整体设计如下图所示：
（系统类图）

先对系统类设计进行详细说明。

首先定义实体类接口，实体类接口定义了实体类应具备哪些操作，在我们的指纹认证系统中，我们定义了IUserOperation接口和IFingerprintOperation接口。IUserOperation接口定义了User实体类应该具有的操作，具体包含了insertToUser方法和isExistUser方法，分别用于添加用户和判断用户是否存在；IFingerprintOperation接口定义了insertToFingerprint方法和getImages方法，分别用于添加指纹图片和获取所有指纹图片。

其次定义实体类，实体类反映了该系统实际操作的对象，在本系统中共定义了User类和Fingerprint类两个实体类。User类定义了用户所具有的属性，包括UserId和UserName属性，并实现了IUserOperation接口，Fingerprint类定义了指纹具有的属性，包括fpId，fpName，sampleNumber，userId和fpPath属性，并实现了IFingerprintOperation接口。

接下来定义实体关联类，关联类反映了用户实体和指纹实体之间一对多的关系。共定义了一个关联类UserFingerprint类，共包含3个属性，ufID属性，userId属性和fpId属性。通过此类建立起User类和Fingerprint类之间的关系。

最后定义控制器类，我们主要定义了UserController和FingerprintController两个控制器类用于操作相应的数据实体类。两个控制器类分别以来对应的数据实体类。其中UserController类定义了insertUser和getUser两个方法，分别用于添加用户和获取所有用户；FingerprintController类定义了uploadFingerprint方法、matchFingerprint方法、generateQrcode方法和verificationUser方法，分别用于用户上传指纹、用户匹配指纹、生成二维码和验证用户真实性。

在系统中，对应于数据实体类和控制器类，实际上还有视图类，但是由于视图类基本上都是负责显示逻辑的HTML代码，与系统业务逻辑关联并不大，因此并不刻意反映在系统整体类图中。

### 4.2.3 分模块详细设计
在整体类图的基础上，本部分对系统几个核心模块进行详细设计。在本系统中，我们认为用户指纹录入和用户指纹匹配两个模块最为重要和关键。

（1）用户指纹录入模块详细设计

（2）用户指纹匹配模块详细设计
## 4.3 数据库设计
### 4.3.1 E-R图
### 4.3.2 数据库详细设计

# 5. 系统实现
## 5.1 模型模块实现
## 5.2 视图模块实现
## 5.3 控制器模块实现
## 5.4 关键算法实现

# 6. 实验结果
## 6.1 基于Matlab的仿真实验
## 6.1 成本与可用性分析
## 6.2 安全性分析

# 7. 总结与展望
